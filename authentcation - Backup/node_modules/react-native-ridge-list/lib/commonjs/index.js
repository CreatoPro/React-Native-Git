"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = FlatList;

var React = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactWindowInfiniteLoader = _interopRequireDefault(require("react-window-infinite-loader"));

var _reactWindow = require("react-window");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const outerElementTypeWithTestId = testID => /*#__PURE__*/React.forwardRef((props, ref) =>
/*#__PURE__*/
// @ts-ignore
React.createElement("div", _extends({
  ref: ref,
  "data-testid": testID
}, props)));

function FlatList(props) {
  const outerRef = React.useRef(undefined);
  const {
    ListHeaderComponent,
    ListHeaderComponentStyle,
    numColumns = 1,
    maxToRenderPerBatch = 20,
    data,
    renderItem,
    getItemLayout,
    onEndReached,
    inverted,
    testID
  } = props;
  const onEndReachedThreshold = props.onEndReachedThreshold || 15;

  if (!getItemLayout) {
    throw Error('getItemLayout is required with react-native-ridge');
  }

  const [layout, setLayout] = React.useState({
    width: 0,
    height: 0
  });
  React.useEffect(() => {
    if (!inverted) {
      return;
    }

    const ref = outerRef.current;

    const listener = e => {
      e.preventDefault();

      if (ref) {
        // only supported in safari but maybe added in the future
        let reverse = e.directionInvertedFromDevice || e.webkitDirectionInvertedFromDevice || e.directionInvertedFromDevice; // fallback on default settings

        if (reverse === undefined) {
          reverse = navigator.platform.indexOf('Mac') > -1;
        }

        if (reverse) {
          ref.scrollTop -= e.deltaY;
        } else {
          ref.scrollTop += e.deltaY;
        }
      }

      return false;
    };

    if (ref) {
      ref.addEventListener('wheel', listener, {
        passive: false
      });
      return () => {
        ref.removeEventListener('wheel', listener);
      };
    }

    return;
  }, [inverted]);

  const Grid = ({
    columnIndex,
    rowIndex,
    style
  }) => {
    const index = rowIndex + columnIndex;
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react-native/no-inline-styles
      React.createElement("div", {
        style: inverted ? { ...style,
          transform: 'scale(-1)'
        } : style
      }, data && data.length > 0 && renderItem ? renderItem({
        index,
        item: data && data[index]
      }) : null)
    );
  };

  const Row = ({
    index,
    style
  }) =>
  /*#__PURE__*/
  // eslint-disable-next-line react-native/no-inline-styles
  React.createElement("div", {
    style: inverted ? { ...style,
      transform: 'scale(-1)'
    } : style
  }, index === 0 ? ListHeaderComponent && /*#__PURE__*/React.createElement(_reactNative.View, {
    style: ListHeaderComponentStyle
  }, typeof ListHeaderComponent === 'function' ? ListHeaderComponent() : ListHeaderComponent) : null, data && data.length > 0 && renderItem ? renderItem({
    index,
    item: data && data[index]
  }) : null);

  const getItemSize = index => {
    const layoutHeight = getItemLayout(data, index).length;

    if (index === 0 && (ListHeaderComponent || ListHeaderComponentStyle)) {
      if (ListHeaderComponentStyle) {
        const {
          marginTop,
          marginBottom,
          paddingTop,
          paddingBottom,
          height
        } = _reactNative.StyleSheet.flatten(ListHeaderComponentStyle);

        return layoutHeight + (Number(marginTop) || 0) + (Number(marginBottom) || 0) + (Number(paddingTop) || 0) + (Number(paddingBottom) || 0) + (Number(height) || 0);
      } // to add support for header


      if (ListHeaderComponent) {
        return layoutHeight * 2;
      }
    }

    return layoutHeight;
  };

  const getItemWidth = _ => {
    return layout.width / numColumns;
  };

  const itemCount = data && data.length > 0 ? data.length : 1; // to add support for header

  const isItemLoaded = index => index < itemCount;

  const onLoadMore = React.useCallback((_, stopIndex) => {
    const total = getItemLayout(data, data.length - 1);
    const totalHeight = total.offset + total.length;
    const offset = getItemLayout(data, stopIndex).offset;
    onEndReached === null || onEndReached === void 0 ? void 0 : onEndReached({
      distanceFromEnd: totalHeight - offset
    });
    return null;
  }, [data, getItemLayout, onEndReached]);
  const outerElementType = React.useMemo(() => outerElementTypeWithTestId(testID), [testID]);
  let inner;

  if (numColumns > 1) {
    inner = /*#__PURE__*/React.createElement(_reactWindowInfiniteLoader.default, {
      isItemLoaded: isItemLoaded,
      itemCount: itemCount + maxToRenderPerBatch,
      loadMoreItems: onLoadMore,
      minimumBatchSize: maxToRenderPerBatch,
      threshold: onEndReachedThreshold
    }, ({
      onItemsRendered,
      ref
    }) => /*#__PURE__*/React.createElement(_reactWindow.VariableSizeGrid, {
      ref: ref,
      outerRef: outerRef,
      outerElementType: outerElementType,
      onItemsRendered: onItemsRendered,
      width: layout.width,
      height: layout.height,
      columnCount: numColumns,
      rowHeight: getItemSize,
      columnWidth: getItemWidth,
      rowCount: Math.ceil(itemCount / numColumns)
    }, Grid));
  } else {
    inner = /*#__PURE__*/React.createElement(_reactWindowInfiniteLoader.default, {
      isItemLoaded: isItemLoaded,
      itemCount: itemCount + maxToRenderPerBatch,
      loadMoreItems: onLoadMore,
      minimumBatchSize: maxToRenderPerBatch,
      threshold: onEndReachedThreshold
    }, ({
      onItemsRendered,
      ref
    }) => /*#__PURE__*/React.createElement(_reactWindow.VariableSizeList, {
      ref: ref,
      outerRef: outerRef,
      outerElementType: outerElementType,
      onItemsRendered: onItemsRendered,
      width: layout.width,
      height: layout.height,
      itemSize: getItemSize,
      itemCount: itemCount
    }, Row));
  }

  const onLayout = React.useCallback(({
    nativeEvent: {
      layout: {
        width,
        height
      }
    }
  }) => {
    setLayout({
      width,
      height
    });
  }, [setLayout]);
  return /*#__PURE__*/React.createElement(_reactNative.View, {
    onLayout: onLayout,
    style: [props.style, inverted && styles.invertedContainer]
  }, layout.width > 0 && layout.height > 0 ? inner : null);
}

const styles = _reactNative.StyleSheet.create({
  invertedContainer: {
    transform: [{
      scale: -1
    }]
  },
  invertedItem: {}
});
//# sourceMappingURL=index.js.map