function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import * as React from 'react';
import { View } from 'react-native';
import { StyleSheet } from 'react-native';
import InfiniteLoader from 'react-window-infinite-loader';
import { VariableSizeList, VariableSizeGrid } from 'react-window';

const outerElementTypeWithTestId = testID => /*#__PURE__*/React.forwardRef((props, ref) =>
/*#__PURE__*/
// @ts-ignore
React.createElement("div", _extends({
  ref: ref,
  "data-testid": testID
}, props)));

export default function FlatList(props) {
  const outerRef = React.useRef(undefined);
  const {
    ListHeaderComponent,
    ListHeaderComponentStyle,
    numColumns = 1,
    maxToRenderPerBatch = 20,
    data,
    renderItem,
    getItemLayout,
    onEndReached,
    inverted,
    testID
  } = props;
  const onEndReachedThreshold = props.onEndReachedThreshold || 15;

  if (!getItemLayout) {
    throw Error('getItemLayout is required with react-native-ridge');
  }

  const [layout, setLayout] = React.useState({
    width: 0,
    height: 0
  });
  React.useEffect(() => {
    if (!inverted) {
      return;
    }

    const ref = outerRef.current;

    const listener = e => {
      e.preventDefault();

      if (ref) {
        // only supported in safari but maybe added in the future
        let reverse = e.directionInvertedFromDevice || e.webkitDirectionInvertedFromDevice || e.directionInvertedFromDevice; // fallback on default settings

        if (reverse === undefined) {
          reverse = navigator.platform.indexOf('Mac') > -1;
        }

        if (reverse) {
          ref.scrollTop -= e.deltaY;
        } else {
          ref.scrollTop += e.deltaY;
        }
      }

      return false;
    };

    if (ref) {
      ref.addEventListener('wheel', listener, {
        passive: false
      });
      return () => {
        ref.removeEventListener('wheel', listener);
      };
    }

    return;
  }, [inverted]);

  const Grid = ({
    columnIndex,
    rowIndex,
    style
  }) => {
    const index = rowIndex + columnIndex;
    return (
      /*#__PURE__*/
      // eslint-disable-next-line react-native/no-inline-styles
      React.createElement("div", {
        style: inverted ? { ...style,
          transform: 'scale(-1)'
        } : style
      }, data && data.length > 0 && renderItem ? renderItem({
        index,
        item: data && data[index]
      }) : null)
    );
  };

  const Row = ({
    index,
    style
  }) =>
  /*#__PURE__*/
  // eslint-disable-next-line react-native/no-inline-styles
  React.createElement("div", {
    style: inverted ? { ...style,
      transform: 'scale(-1)'
    } : style
  }, index === 0 ? ListHeaderComponent && /*#__PURE__*/React.createElement(View, {
    style: ListHeaderComponentStyle
  }, typeof ListHeaderComponent === 'function' ? ListHeaderComponent() : ListHeaderComponent) : null, data && data.length > 0 && renderItem ? renderItem({
    index,
    item: data && data[index]
  }) : null);

  const getItemSize = index => {
    const layoutHeight = getItemLayout(data, index).length;

    if (index === 0 && (ListHeaderComponent || ListHeaderComponentStyle)) {
      if (ListHeaderComponentStyle) {
        const {
          marginTop,
          marginBottom,
          paddingTop,
          paddingBottom,
          height
        } = StyleSheet.flatten(ListHeaderComponentStyle);
        return layoutHeight + (Number(marginTop) || 0) + (Number(marginBottom) || 0) + (Number(paddingTop) || 0) + (Number(paddingBottom) || 0) + (Number(height) || 0);
      } // to add support for header


      if (ListHeaderComponent) {
        return layoutHeight * 2;
      }
    }

    return layoutHeight;
  };

  const getItemWidth = _ => {
    return layout.width / numColumns;
  };

  const itemCount = data && data.length > 0 ? data.length : 1; // to add support for header

  const isItemLoaded = index => index < itemCount;

  const onLoadMore = React.useCallback((_, stopIndex) => {
    const total = getItemLayout(data, data.length - 1);
    const totalHeight = total.offset + total.length;
    const offset = getItemLayout(data, stopIndex).offset;
    onEndReached === null || onEndReached === void 0 ? void 0 : onEndReached({
      distanceFromEnd: totalHeight - offset
    });
    return null;
  }, [data, getItemLayout, onEndReached]);
  const outerElementType = React.useMemo(() => outerElementTypeWithTestId(testID), [testID]);
  let inner;

  if (numColumns > 1) {
    inner = /*#__PURE__*/React.createElement(InfiniteLoader, {
      isItemLoaded: isItemLoaded,
      itemCount: itemCount + maxToRenderPerBatch,
      loadMoreItems: onLoadMore,
      minimumBatchSize: maxToRenderPerBatch,
      threshold: onEndReachedThreshold
    }, ({
      onItemsRendered,
      ref
    }) => /*#__PURE__*/React.createElement(VariableSizeGrid, {
      ref: ref,
      outerRef: outerRef,
      outerElementType: outerElementType,
      onItemsRendered: onItemsRendered,
      width: layout.width,
      height: layout.height,
      columnCount: numColumns,
      rowHeight: getItemSize,
      columnWidth: getItemWidth,
      rowCount: Math.ceil(itemCount / numColumns)
    }, Grid));
  } else {
    inner = /*#__PURE__*/React.createElement(InfiniteLoader, {
      isItemLoaded: isItemLoaded,
      itemCount: itemCount + maxToRenderPerBatch,
      loadMoreItems: onLoadMore,
      minimumBatchSize: maxToRenderPerBatch,
      threshold: onEndReachedThreshold
    }, ({
      onItemsRendered,
      ref
    }) => /*#__PURE__*/React.createElement(VariableSizeList, {
      ref: ref,
      outerRef: outerRef,
      outerElementType: outerElementType,
      onItemsRendered: onItemsRendered,
      width: layout.width,
      height: layout.height,
      itemSize: getItemSize,
      itemCount: itemCount
    }, Row));
  }

  const onLayout = React.useCallback(({
    nativeEvent: {
      layout: {
        width,
        height
      }
    }
  }) => {
    setLayout({
      width,
      height
    });
  }, [setLayout]);
  return /*#__PURE__*/React.createElement(View, {
    onLayout: onLayout,
    style: [props.style, inverted && styles.invertedContainer]
  }, layout.width > 0 && layout.height > 0 ? inner : null);
}
const styles = StyleSheet.create({
  invertedContainer: {
    transform: [{
      scale: -1
    }]
  },
  invertedItem: {}
});
//# sourceMappingURL=index.js.map